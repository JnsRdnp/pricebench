"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const OBJECT = { type: 'object' };
const ARRAY = { type: 'array' };
const BOOLEAN = { type: 'boolean' };
const INTEGER = { type: 'integer' };
const NUMBER = { type: 'number' };
const STRING = { type: 'string' };
const ANY = { anyOf: [OBJECT, ARRAY, BOOLEAN, INTEGER, NUMBER, STRING] };
class TypeMapper {
    map(attributeName, properties, strategy) {
        let result;
        let attributeType = properties && properties.type && properties.type['key'];
        switch (attributeType) {
            case 'VIRTUAL': {
                attributeType = properties.type && properties.type['returnType'] && properties.type['returnType']['key'];
                break;
            }
            default:
                break;
        }
        switch (attributeType) {
            case 'ARRAY': {
                result = Object.assign(Object.assign({}, ARRAY), { items: this.map(attributeName, { type: properties.type['type'], allowNull: false }, strategy) });
                break;
            }
            case 'BIGINT': {
                result = Object.assign(Object.assign({}, INTEGER), { format: 'int64' });
                break;
            }
            case 'BLOB': {
                result = Object.assign({}, STRING);
                Object.assign(result, strategy.getPropertyForBase64Encoding());
                break;
            }
            case 'BOOLEAN': {
                result = Object.assign({}, BOOLEAN);
                break;
            }
            case 'CIDR': {
                result = Object.assign({}, STRING);
                break;
            }
            case 'CITEXT': {
                result = Object.assign({}, STRING);
                break;
            }
            case 'DATE': {
                result = Object.assign(Object.assign({}, STRING), { format: 'date-time' });
                break;
            }
            case 'DATEONLY': {
                result = Object.assign(Object.assign({}, STRING), { format: 'date' });
                break;
            }
            case 'TIME': {
                result = Object.assign(Object.assign({}, STRING), { format: 'time' });
                break;
            }
            case 'DECIMAL': {
                result = Object.assign({}, NUMBER);
                break;
            }
            case 'DOUBLE PRECISION': {
                result = Object.assign(Object.assign({}, NUMBER), { format: 'double' });
                break;
            }
            case 'ENUM': {
                result = Object.assign(Object.assign({}, STRING), { enum: [...(properties.values || properties.type['values'])] });
                break;
            }
            case 'INTEGER': {
                result = Object.assign({}, INTEGER);
                break;
            }
            case 'INET': {
                result = {
                    type: [
                        Object.assign(Object.assign({}, STRING), { format: 'ipv4' }),
                        Object.assign(Object.assign({}, STRING), { format: 'ipv6' }),
                    ],
                };
                break;
            }
            case 'FLOAT': {
                result = Object.assign(Object.assign({}, NUMBER), { format: 'float' });
                break;
            }
            case 'JSON': {
                result = Object.assign({}, ANY);
                break;
            }
            case 'JSONB': {
                result = Object.assign({}, ANY);
                break;
            }
            case 'MACADDR': {
                result = Object.assign({}, STRING);
                break;
            }
            case 'REAL': {
                result = Object.assign({}, NUMBER);
                break;
            }
            case 'STRING': {
                result = Object.assign({}, STRING);
                if (properties.type['options'].length !== undefined) {
                    result.maxLength = properties.type['options'].length;
                }
                break;
            }
            case 'TEXT': {
                result = Object.assign({}, STRING);
                break;
            }
            case 'UUID': {
                result = Object.assign(Object.assign({}, STRING), { format: 'uuid' });
                break;
            }
            case 'UUIDV1': {
                result = Object.assign(Object.assign({}, STRING), { format: 'uuid' });
                break;
            }
            case 'UUIDV4': {
                result = Object.assign(Object.assign({}, STRING), { format: 'uuid' });
                break;
            }
            case 'CHAR': {
                result = Object.assign({}, STRING);
                break;
            }
            case 'MEDIUMINT': {
                result = Object.assign({}, INTEGER);
                break;
            }
            case 'NUMBER': {
                result = Object.assign({}, NUMBER);
                break;
            }
            case 'SMALLINT': {
                result = Object.assign({}, INTEGER);
                break;
            }
            case 'TINYINT': {
                result = Object.assign({}, NUMBER);
                break;
            }
            case 'VIRTUAL': {
                result = this.map(attributeName, Object.assign(Object.assign({}, properties), { type: properties.type && properties.type['returnType'] }), strategy);
                break;
            }
            default:
                result = Object.assign({}, ANY);
        }
        if (properties.allowNull !== false)
            Object.assign(result, this.getNullableType(result['anyOf'] || result['type'], strategy));
        if (properties.defaultValue !== undefined)
            result.default = properties.defaultValue;
        return result;
    }
    getNullableType(type, strategy) {
        const result = strategy.convertTypePropertyToAllowNull(type);
        if (typeof result !== 'object')
            throw new TypeError("convertTypePropertyToAllowNull() return value not of type 'object'");
        if (!Object.prototype.hasOwnProperty.call(result, 'type') &&
            !Object.prototype.hasOwnProperty.call(result, 'anyOf')) {
            throw new TypeError("convertTypePropertyToAllowNull() return value does not have property 'type' or 'anyOf'");
        }
        return result;
    }
}
exports.default = TypeMapper;
//# sourceMappingURL=type-mapper.js.map